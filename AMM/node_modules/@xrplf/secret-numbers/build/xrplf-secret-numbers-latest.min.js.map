{"version":3,"file":"xrplf-secret-numbers-latest.min.js","mappings":"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","sources":["webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/_shortw_utils.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/curve.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/edwards.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/hash-to-curve.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/modular.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/montgomery.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/weierstrass.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/ed25519.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/secp256k1.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/_assert.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/_sha2.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/_u64.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/crypto.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/hmac.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/ripemd160.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/sha256.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/sha512.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/@scure/base/lib/index.js","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/internal/normalizeInput.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/internal/wrapNoble.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/ripemd160/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/sha256/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/sha512/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/utils/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/utils/shared.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-address-codec/src/index.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-address-codec/src/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-address-codec/src/xrp-codec.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/index.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/signing-schemes/ed25519/index.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/signing-schemes/secp256k1/index.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/signing-schemes/secp256k1/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/utils/Sha512.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/utils/assert.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/utils/getAlgorithmFromKey.ts","webpack://xrplf_secret_numbers/./src/index.ts","webpack://xrplf_secret_numbers/./src/schema/Account.ts","webpack://xrplf_secret_numbers/./src/utils/index.ts","webpack://xrplf_secret_numbers/webpack/bootstrap","webpack://xrplf_secret_numbers/webpack/startup"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport { weierstrass, CurveType } from './abstract/weierstrass.js';\nimport { CHash } from './abstract/utils.js';\n\n// connects noble-curves to noble-hashes\nexport function getHash(hash: CHash) {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n// Same API as @noble/hashes, with ability to create curve with custom hash\ntype CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport function createCurve(curveDef: CurveDef, defHash: CHash) {\n  const create = (hash: CHash) => weierstrass({ ...curveDef, ...getHash(hash) });\n  return Object.freeze({ ...create(defHash), create });\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  const constTimeNegate = (condition: boolean, item: T): T => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = (W: number) => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint) {\n      let p = c.ZERO;\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = opts(W);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = opts(W);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      // @ts-ignore\n      const W: number = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    },\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, FHash, Hex } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n// Edwards curves must declare params a & d.\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n// Instance of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n// Static methods of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n  };\n};\n\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  const inBig = (n: bigint) => typeof n === 'bigint' && _0n < n; // n in [1..]\n  const inRange = (n: bigint, max: bigint) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n  const in0MaskRange = (n: bigint) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n  function assertInRange(n: bigint, max: bigint) {\n    // n in [1..max-1]\n    if (inRange(n, max)) return n;\n    throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n  }\n  function assertGE0(n: bigint) {\n    // n in [0..CURVE_ORDER-1]\n    return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n  }\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function isPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n\n    constructor(\n      readonly ex: bigint,\n      readonly ey: bigint,\n      readonly ez: bigint,\n      readonly et: bigint\n    ) {\n      if (!in0MaskRange(ex)) throw new Error('x required');\n      if (!in0MaskRange(ey)) throw new Error('y required');\n      if (!in0MaskRange(ez)) throw new Error('z required');\n      if (!in0MaskRange(et)) throw new Error('t required');\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error('invalid affine point');\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      const { a, d } = CURVE;\n      if (this.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n      // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n      // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n      const { ex: X, ey: Y, ez: Z, et: T } = this;\n      const X2 = modP(X * X); // X²\n      const Y2 = modP(Y * Y); // Y²\n      const Z2 = modP(Z * Z); // Z²\n      const Z4 = modP(Z2 * Z2); // Z⁴\n      const aX2 = modP(X2 * a); // aX²\n      const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n      const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n      if (left !== right) throw new Error('bad point: equation left != right (1)');\n      // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n      const XY = modP(X * Y);\n      const ZT = modP(Z * T);\n      if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      isPoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    protected is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      isPoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      // Faster algo for adding 2 Extended Points when curve's a=-1.\n      // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n      // Cost: 8M + 8add + 2*2.\n      // Note: It does not check whether the `other` point is valid.\n      if (a === BigInt(-1)) {\n        const A = modP((Y1 - X1) * (Y2 + X2));\n        const B = modP((Y1 + X1) * (Y2 - X2));\n        const F = modP(B - A);\n        if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n        const C = modP(Z1 * _2n * T2);\n        const D = modP(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    multiplyUnsafe(scalar: bigint): Point {\n      let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n      if (n === _0n) return I;\n      if (this.equals(I) || n === _1n) return this;\n      if (this.equals(G)) return this.wNAF(n).p;\n      return wnaf.unsafeLadder(this, n);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      const { ex: x, ey: y, ez: z } = this;\n      const is0 = this.is0();\n      if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n      const ax = modP(x * iz);\n      const ay = modP(y * iz);\n      const zz = modP(z * iz);\n      if (is0) return { x: _0n, y: _1n };\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = ut.bytesToNumberLE(normed);\n      if (y === _0n) {\n        // y=0 is allowed\n      } else {\n        // RFC8032 prohibits >= p, but ZIP215 doesn't\n        if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n        else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n      }\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex) {\n      return getExtendedPublicKey(privKey).point;\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key: Hex) {\n    const len = nByteLength;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = new Uint8Array(), ...msgs: Uint8Array[]) {\n    const msg = ut.concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    assertGE0(s); // 0 <= s < l\n    const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    // zip215: true is good for consensus-critical apps and allows points < 2^256\n    // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n    let A, R, SB;\n    try {\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { Group, GroupConstructor, AffinePoint } from './curve.js';\nimport { mod, IField } from './modular.js';\nimport { bytesToNumberBE, CHash, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\ntype UnicodeOrBytes = string | Uint8Array;\nexport type Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n\nfunction validateDST(dst: UnicodeOrBytes): Uint8Array {\n  if (dst instanceof Uint8Array) return dst;\n  if (typeof dst === 'string') return utf8ToBytes(dst);\n  throw new Error('DST must be Uint8Array or string');\n}\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  if (value < 0 || value >= 1 << (8 * length)) {\n    throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n  }\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction isBytes(item: unknown): void {\n  if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');\n}\nfunction isNum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (ell > 255) throw new Error('Invalid xmd length');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][] {\n  validateObject(options, {\n    DST: 'stringOrUint8Array',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash',\n  });\n  const { p, k, m, hash, expand, DST: _DST } = options;\n  isBytes(msg);\n  isNum(count);\n  const DST = validateDST(_DST);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: [T[], T[], T[], T[]]) {\n  // Make same order as in spec\n  const COEFF = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xNum, xDen, yNum, yDen] = COEFF.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    x = field.div(xNum, xDen); // xNum / xDen\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\n\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  def: Opts & { encodeDST?: UnicodeOrBytes }\n) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  return {\n    // Encodes byte string to elliptic curve.\n    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options } as Opts);\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\n      const P = u0.add(u1).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n\n    // Encodes byte string to elliptic curve.\n    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options } as Opts);\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n  };\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from './utils.js';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  nByteLength: number;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  a: bigint;\n  montgomeryBits: number;\n  powPminus2?: (x: bigint) => bigint;\n  xyToU?: (x: bigint, y: bigint) => bigint;\n  Gu: bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(\n    curve,\n    {\n      a: 'bigint',\n    },\n    {\n      montgomeryBits: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      powPminus2: 'function',\n      Gu: 'bigint',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...curve } as const);\n}\n\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P } = CURVE;\n  const modP = (n: bigint) => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const powPminus2 = CURVE.powPminus2 || ((x: bigint) => pow(x, P - BigInt(2), P));\n\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): [bigint, bigint] {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n\n  // Accepts 0 as well\n  function assertFieldElement(n: bigint): bigint {\n    if (typeof n === 'bigint' && _0n <= n && n < P) return n;\n    throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n  }\n\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(pointU: bigint, scalar: bigint): bigint {\n    const u = assertFieldElement(pointU);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = assertFieldElement(scalar);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw: [bigint, bigint];\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n\n  function encodeUCoordinate(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n\n  function decodeUCoordinate(uEnc: Hex): bigint {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    // This is very ugly way, but it works because fieldLen-1 is outside of bounds for X448, so this becomes NOOP\n    // fieldLen - scalaryBytes = 1 for X448 and = 0 for X25519\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    // u[fieldLen-1] crashes QuickJS (TypeError: out-of-bound numeric index)\n    if (fieldLen === montgomeryBytes) u[fieldLen - 1] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n: Hex): bigint {\n    const bytes = ensureBytes('scalar', n);\n    if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)\n      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(CURVE.nByteLength) },\n    GuBytes: GuBytes,\n  };\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || val instanceof Uint8Array,\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | true;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\n    const { Err: E } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\n      throw new E('Invalid signature integer: unnecessary leading zero');\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return { r, s };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n    const h = (num: number | bigint) => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>) {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula\n   * @returns y²\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num: bigint) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(readonly px: T, readonly py: T, readonly pz: T) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      if (this.is0()) {\n        // (0, 1, 0) aka ZERO is invalid in most contexts.\n        // In BLS, ZERO can be serialized, so we allow it.\n        // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n        if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const { x, y } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y²\n      const right = weierstrassEquation(x); // x³ + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    private is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n: bigint): Point {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const { endo } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n\n      // Apply endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      assertGE(scalar);\n      let n = scalar;\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const { endo } = CURVE;\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      const { px: x, py: y, pz: z } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num: bigint): boolean {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n        let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        throw new Error(\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(readonly r: bigint, readonly s: bigint, readonly recovery?: number) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = mod.getMinHashLength(CURVE.n);\n      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK))\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const { lowS, prehash } = opts;\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const { r, s } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if ((error as Error).message === 'PARSE')\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { ExtPointType, twistedEdwards } from './abstract/edwards.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  Hex,\n  numberToBytesLE,\n} from './abstract/utils.js';\nimport { createHasher, htfBasicOpts, expand_message_xmd } from './abstract/hash-to-curve.js';\nimport { AffinePoint } from './abstract/curve.js';\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v³\n  const v7 = mod(v3 * v3 * v, P); // v⁷\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx²\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = Field(ED25519_P, undefined, true);\n\nconst ed25519Defaults = {\n  // Param: a\n  a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n  // d is equal to -121665/121666 over finite field.\n  // Negative number is P - number, and division is invert(number, P)\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n  Fp,\n  // Subgroup order: how many points curve has\n  // 2n**252n + 27742317777372353535851937790883648493n;\n  n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n  // Cofactor\n  h: BigInt(8),\n  // Base point (x, y) aka generator point\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n  hash: sha512,\n  randomBytes,\n  adjustScalarBytes,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/√v\n  uvRatio,\n} as const;\n\nexport const ed25519 = /* @__PURE__ */ twistedEdwards(ed25519Defaults);\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx = /* @__PURE__ */ twistedEdwards({\n  ...ed25519Defaults,\n  domain: ed25519_domain,\n});\nexport const ed25519ph = /* @__PURE__ */ twistedEdwards({\n  ...ed25519Defaults,\n  domain: ed25519_domain,\n  prehash: sha512,\n});\n\nexport const x25519 = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\n\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  let tv1 = Fp.sqr(u);       //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);  //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);      //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);     //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);         //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);         //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);         //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);          //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n\n  const inv = Fp.invertBatch([xd, yd]); // batch division\n  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\n\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n\nfunction assertRstPoint(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d²\nconst ONE_MINUS_D_SQ = BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)²\nconst D_MINUS_ONE_SQ = BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/√(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(private readonly ep: ExtendedPoint) {}\n\n  static fromAffine(ap: AffinePoint<bigint>) {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * https://ristretto.group/formulas/elligator.html\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * https://ristretto.group/formulas/decoding.html\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * https://ristretto.group/formulas/encoding.html\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  // Compare one point to another.\n  equals(other: RistPoint): boolean {\n    assertRstPoint(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts) => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n","/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport { ProjPointType as PointType, mapToCurveSimpleSWU } from './abstract/weierstrass.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport { bytesToNumberBE, concatBytes, ensureBytes, numberToBytesBE } from './abstract/utils.js';\nimport { createHasher, isogenyMap } from './abstract/hash-to-curve.js';\nimport { createCurve } from './_shortw_utils.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\nexport const secp256k1 = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x: bigint) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(bytesToNumberBE(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ bytesToNumberBE(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(bytesToNumberBE(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(bytesToNumberBE(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = bytesToNumberBE(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n    if (!fe(r)) return false;\n    const s = bytesToNumberBE(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n    if (!ge(s)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport const schnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fp,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fp.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n","function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assertHash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assertExists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assertExists(this);\n    assertBytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++) for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));\n\nconst shifts = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word: number, shift: number) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  else if (group === 1) return (x & y) | (~x & z);\n  else if (group === 2) return (x | ~y) ^ z;\n  else if (group === 3) return (x & z) | (y & ~z);\n  else return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number) {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean() {\n    BUF.fill(0);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x6a09e667 | 0;\n  Al = 0xf3bcc908 | 0;\n  Bh = 0xbb67ae85 | 0;\n  Bl = 0x84caa73b | 0;\n  Ch = 0x3c6ef372 | 0;\n  Cl = 0xfe94f82b | 0;\n  Dh = 0xa54ff53a | 0;\n  Dl = 0x5f1d36f1 | 0;\n  Eh = 0x510e527f | 0;\n  El = 0xade682d1 | 0;\n  Fh = 0x9b05688c | 0;\n  Fl = 0x2b3e6c1f | 0;\n  Gh = 0x1f83d9ab | 0;\n  Gl = 0xfb41bd6b | 0;\n  Hh = 0x5be0cd19 | 0;\n  Hl = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nclass SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x8c3d37c8 | 0;\n  Al = 0x19544da2 | 0;\n  Bh = 0x73e19966 | 0;\n  Bl = 0x89dcd4d6 | 0;\n  Ch = 0x1dfab7ae | 0;\n  Cl = 0x32ff9c82 | 0;\n  Dh = 0x679dd514 | 0;\n  Dl = 0x582f9fcf | 0;\n  Eh = 0x0f6d2b69 | 0;\n  El = 0x7bd44da8 | 0;\n  Fh = 0x77e36f73 | 0;\n  Fl = 0x04c48942 | 0;\n  Gh = 0x3f9d85a8 | 0;\n  Gl = 0x6a1d36c8 | 0;\n  Hh = 0x1112e6ad | 0;\n  Hl = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nclass SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x22312194 | 0;\n  Al = 0xfc2bf72c | 0;\n  Bh = 0x9f555fa3 | 0;\n  Bl = 0xc84c64c2 | 0;\n  Ch = 0x2393b86b | 0;\n  Cl = 0x6f53b151 | 0;\n  Dh = 0x96387719 | 0;\n  Dl = 0x5940eabd | 0;\n  Eh = 0x96283ee2 | 0;\n  El = 0xa88effe3 | 0;\n  Fh = 0xbe5e1e25 | 0;\n  Fl = 0x53863992 | 0;\n  Gh = 0x2b0199fc | 0;\n  Gl = 0x2c85b8aa | 0;\n  Hh = 0x0eb72ddc | 0;\n  Hl = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nclass SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0xcbbb9d5d | 0;\n  Al = 0xc1059ed8 | 0;\n  Bh = 0x629a292a | 0;\n  Bl = 0x367cd507 | 0;\n  Ch = 0x9159015a | 0;\n  Cl = 0x3070dd17 | 0;\n  Dh = 0x152fecd8 | 0;\n  Dl = 0xf70e5939 | 0;\n  Eh = 0x67332667 | 0;\n  El = 0xffc00b31 | 0;\n  Fh = 0x8eb44a87 | 0;\n  Fl = 0x68581511 | 0;\n  Gh = 0xdb0c2e0d | 0;\n  Gl = 0x64f98fa7 | 0;\n  Hh = 0x47b5481d | 0;\n  Hl = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\n// RFC 4648 aka RFC 3548\n// ---------------------\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n","import { Input } from './types'\n\n/**\n * Normalize a string, number array, or Uint8Array to a string or Uint8Array.\n * Both node and noble lib functions accept these types.\n *\n * @param input - value to normalize\n */\nexport default function normalizeInput(input: Input): string | Uint8Array {\n  return Array.isArray(input) ? new Uint8Array(input) : input\n}\n","import { CHash } from '@noble/hashes/utils'\nimport { Hash, HashFn, Input } from './types'\nimport normalizeInput from './normalizeInput'\n\n/**\n * Wrap a CHash object from @noble/hashes to provide a interface that is isomorphic\n *\n * @param chash - {CHash} hash function to wrap\n */\nexport default function wrapNoble(chash: CHash): HashFn {\n  function wrapped(input: Input): Uint8Array {\n    return chash(normalizeInput(input))\n  }\n\n  wrapped.create = (): Hash => {\n    const hash = chash.create()\n    return {\n      update(input: Input): Hash {\n        hash.update(normalizeInput(input))\n        return this\n      },\n      digest(): Uint8Array {\n        return hash.digest()\n      },\n    }\n  }\n  return wrapped\n}\n","import { ripemd160 as nobleImpl } from '@noble/hashes/ripemd160'\n\nimport wrapNoble from '../internal/wrapNoble'\n\n/**\n * Wrap noble-libs's ripemd160 implementation in HashFn\n */\nexport const ripemd160 = wrapNoble(nobleImpl)\n","import { sha256 as nobleImpl } from '@noble/hashes/sha256'\n\nimport wrapNoble from '../internal/wrapNoble'\n\n/**\n * Wrap noble-libs's sha256 implementation in HashFn\n */\nexport const sha256 = wrapNoble(nobleImpl)\n","import { sha512 as nobleImpl } from '@noble/hashes/sha512'\n\nimport wrapNoble from '../internal/wrapNoble'\n\n/**\n * Wrap noble-libs's sha512 implementation in HashFn\n */\nexport const sha512 = wrapNoble(nobleImpl)\n","import {\n  bytesToHex as nobleBytesToHex,\n  randomBytes as nobleRandomBytes,\n} from '@noble/hashes/utils'\nimport type {\n  BytesToHexFn,\n  HexToBytesFn,\n  HexToStringFn,\n  RandomBytesFn,\n  StringToHexFn,\n} from './types'\n\n/* eslint-disable func-style -- Typed to ensure uniformity between node and browser implementations and docs */\nexport const bytesToHex: typeof BytesToHexFn = (bytes) => {\n  const hex = nobleBytesToHex(\n    bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes),\n  )\n  return hex.toUpperCase()\n}\n\n// A clone of hexToBytes from @noble/hashes without the length checks. This allows us to do our own checks.\nexport const hexToBytes: typeof HexToBytesFn = (hex): Uint8Array => {\n  const len = hex.length\n  const array = new Uint8Array(len / 2)\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2\n    const hexByte = hex.slice(j, j + 2)\n    const byte = Number.parseInt(hexByte, 16)\n    if (Number.isNaN(byte) || byte < 0) {\n      throw new Error('Invalid byte sequence')\n    }\n    array[i] = byte\n  }\n  return array\n}\n\nexport const hexToString: typeof HexToStringFn = (\n  hex: string,\n  encoding = 'utf8',\n): string => {\n  return new TextDecoder(encoding).decode(hexToBytes(hex))\n}\n\nexport const stringToHex: typeof StringToHexFn = (string: string): string => {\n  return bytesToHex(new TextEncoder().encode(string))\n}\n/* eslint-enable func-style */\n\nexport const randomBytes: typeof RandomBytesFn = nobleRandomBytes\nexport * from './shared'\n","import { concatBytes } from '@noble/hashes/utils'\n\nexport function concat(views: Uint8Array[]): Uint8Array {\n  return concatBytes(...views)\n}\n\nexport function equal(buf1: Uint8Array, buf2: Uint8Array): boolean {\n  if (buf1.byteLength !== buf2.byteLength) {\n    return false\n  }\n  const dv1 = new Int8Array(buf1)\n  const dv2 = new Int8Array(buf2)\n  for (let i = 0; i !== buf1.byteLength; i++) {\n    if (dv1[i] !== dv2[i]) {\n      return false\n    }\n  }\n  return true\n}\n","import { concat, equal, hexToBytes } from '@xrplf/isomorphic/utils'\n\nimport {\n  codec,\n  encodeSeed,\n  decodeSeed,\n  encodeAccountID,\n  decodeAccountID,\n  encodeNodePublic,\n  decodeNodePublic,\n  encodeAccountPublic,\n  decodeAccountPublic,\n  isValidClassicAddress,\n} from './xrp-codec'\n\nconst PREFIX_BYTES = {\n  // 5, 68\n  main: Uint8Array.from([0x05, 0x44]),\n  // 4, 147\n  test: Uint8Array.from([0x04, 0x93]),\n}\n\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295\n\nfunction classicAddressToXAddress(\n  classicAddress: string,\n  tag: number | false,\n  test: boolean,\n): string {\n  const accountId = decodeAccountID(classicAddress)\n  return encodeXAddress(accountId, tag, test)\n}\n\nfunction encodeXAddress(\n  accountId: Uint8Array,\n  tag: number | false,\n  test: boolean,\n): string {\n  if (accountId.length !== 20) {\n    // RIPEMD160 is 160 bits = 20 bytes\n    throw new Error('Account ID must be 20 bytes')\n  }\n  if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {\n    throw new Error('Invalid tag')\n  }\n  const theTag = tag || 0\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n  const flag = tag === false || tag == null ? 0 : 1\n  /* eslint-disable no-bitwise ---\n   * need to use bitwise operations here */\n  const bytes = concat([\n    test ? PREFIX_BYTES.test : PREFIX_BYTES.main,\n    accountId,\n    Uint8Array.from([\n      // 0x00 if no tag, 0x01 if 32-bit tag\n      flag,\n      // first byte\n      theTag & 0xff,\n      // second byte\n      (theTag >> 8) & 0xff,\n      // third byte\n      (theTag >> 16) & 0xff,\n      // fourth byte\n      (theTag >> 24) & 0xff,\n      0,\n      0,\n      0,\n      // four zero bytes (reserved for 64-bit tags)\n      0,\n    ]),\n  ])\n  /* eslint-enable no-bitwise */\n  return codec.encodeChecked(bytes)\n}\n\nfunction xAddressToClassicAddress(xAddress: string): {\n  classicAddress: string\n  tag: number | false\n  test: boolean\n} {\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const { accountId, tag, test } = decodeXAddress(xAddress)\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const classicAddress = encodeAccountID(accountId)\n  return {\n    classicAddress,\n    tag,\n    test,\n  }\n}\n\nfunction decodeXAddress(xAddress: string): {\n  accountId: Uint8Array\n  tag: number | false\n  test: boolean\n} {\n  const decoded = codec.decodeChecked(xAddress)\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const test = isUint8ArrayForTestAddress(decoded)\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const accountId = decoded.slice(2, 22)\n  const tag = tagFromUint8Array(decoded)\n  return {\n    accountId,\n    tag,\n    test,\n  }\n}\n\nfunction isUint8ArrayForTestAddress(buf: Uint8Array): boolean {\n  const decodedPrefix = buf.slice(0, 2)\n  if (equal(PREFIX_BYTES.main, decodedPrefix)) {\n    return false\n  }\n  if (equal(PREFIX_BYTES.test, decodedPrefix)) {\n    return true\n  }\n\n  throw new Error('Invalid X-address: bad prefix')\n}\n\nfunction tagFromUint8Array(buf: Uint8Array): number | false {\n  const flag = buf[22]\n  if (flag >= 2) {\n    // No support for 64-bit tags at this time\n    throw new Error('Unsupported X-address')\n  }\n  if (flag === 1) {\n    // Little-endian to big-endian\n    return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000\n  }\n  if (flag !== 0) {\n    throw new Error('flag must be zero to indicate no tag')\n  }\n  if (!equal(hexToBytes('0000000000000000'), buf.slice(23, 23 + 8))) {\n    throw new Error('remaining bytes must be zero')\n  }\n  return false\n}\n\nfunction isValidXAddress(xAddress: string): boolean {\n  try {\n    decodeXAddress(xAddress)\n  } catch (_error) {\n    return false\n  }\n  return true\n}\n\nexport {\n  // Codec with XRP alphabet\n  codec,\n  // Encode entropy as a \"seed\"\n  encodeSeed,\n  // Decode a seed into an object with its version, type, and bytes\n  decodeSeed,\n  // Encode bytes as a classic address (r...)\n  encodeAccountID,\n  // Decode a classic address to its raw bytes\n  decodeAccountID,\n  // Encode bytes to XRP Ledger node public key format\n  encodeNodePublic,\n  // Decode an XRP Ledger node public key into its raw bytes\n  decodeNodePublic,\n  // Encode a public key, as for payment channels\n  encodeAccountPublic,\n  // Decode a public key, as for payment channels\n  decodeAccountPublic,\n  // Check whether a classic address (r...) is valid\n  isValidClassicAddress,\n  // Derive X-address from classic address, tag, and network ID\n  classicAddressToXAddress,\n  // Encode account ID, tag, and network ID to X-address\n  encodeXAddress,\n  // Decode X-address to account ID, tag, and network ID\n  xAddressToClassicAddress,\n  // Convert X-address to classic address, tag, and network ID\n  decodeXAddress,\n  // Check whether an X-address (X...) is valid\n  isValidXAddress,\n}\n","export type ByteArray = number[] | Uint8Array\n\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nexport function arrayEqual(arr1: ByteArray, arr2: ByteArray): boolean {\n  if (arr1.length !== arr2.length) {\n    return false\n  }\n  return arr1.every((value, index) => value === arr2[index])\n}\n\n/**\n * Check whether a value is a scalar\n *\n * @param val - The value to check.\n */\nfunction isScalar(val: ByteArray | number): val is number {\n  return typeof val === 'number'\n}\n\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\n\nexport function concatArgs(...args: Array<number | ByteArray>): number[] {\n  return args.flatMap((arg) => {\n    return isScalar(arg) ? [arg] : Array.from(arg)\n  })\n}\n","/**\n * Codec class\n */\n\nimport { base58xrp, BytesCoder } from '@scure/base'\nimport { sha256 } from '@xrplf/isomorphic/sha256'\n\nimport { arrayEqual, concatArgs, ByteArray } from './utils'\n\nclass Codec {\n  private readonly _sha256: (bytes: ByteArray) => Uint8Array\n  private readonly _codec: BytesCoder\n\n  public constructor(options: { sha256: (bytes: ByteArray) => Uint8Array }) {\n    this._sha256 = options.sha256\n    this._codec = base58xrp\n  }\n\n  /**\n   * Encoder.\n   *\n   * @param bytes - Uint8Array of data to encode.\n   * @param opts - Options object including the version bytes and the expected length of the data to encode.\n   */\n  public encode(\n    bytes: ByteArray,\n    opts: {\n      versions: number[]\n      expectedLength: number\n    },\n  ): string {\n    const versions = opts.versions\n    return this._encodeVersioned(bytes, versions, opts.expectedLength)\n  }\n\n  /**\n   * Decoder.\n   *\n   * @param base58string - Base58Check-encoded string to decode.\n   * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.\n   */\n  /* eslint-disable max-lines-per-function --\n   * TODO refactor */\n  public decode(\n    base58string: string,\n    opts: {\n      versions: Array<number | number[]>\n      expectedLength?: number\n      versionTypes?: ['ed25519', 'secp256k1']\n    },\n  ): {\n    version: number[]\n    bytes: Uint8Array\n    type: 'ed25519' | 'secp256k1' | null\n  } {\n    const versions = opts.versions\n    const types = opts.versionTypes\n\n    const withoutSum = this.decodeChecked(base58string)\n\n    if (versions.length > 1 && !opts.expectedLength) {\n      throw new Error(\n        'expectedLength is required because there are >= 2 possible versions',\n      )\n    }\n    const versionLengthGuess =\n      typeof versions[0] === 'number' ? 1 : versions[0].length\n    const payloadLength =\n      opts.expectedLength ?? withoutSum.length - versionLengthGuess\n    const versionBytes = withoutSum.slice(0, -payloadLength)\n    const payload = withoutSum.slice(-payloadLength)\n\n    for (let i = 0; i < versions.length; i++) {\n      /* eslint-disable @typescript-eslint/consistent-type-assertions --\n       * TODO refactor */\n      const version: number[] = Array.isArray(versions[i])\n        ? (versions[i] as number[])\n        : [versions[i] as number]\n      if (arrayEqual(versionBytes, version)) {\n        return {\n          version,\n          bytes: payload,\n          type: types ? types[i] : null,\n        }\n      }\n      /* eslint-enable @typescript-eslint/consistent-type-assertions */\n    }\n\n    throw new Error(\n      'version_invalid: version bytes do not match any of the provided version(s)',\n    )\n  }\n\n  public encodeChecked(bytes: ByteArray): string {\n    const check = this._sha256(this._sha256(bytes)).slice(0, 4)\n    return this._encodeRaw(Uint8Array.from(concatArgs(bytes, check)))\n  }\n\n  public decodeChecked(base58string: string): Uint8Array {\n    const intArray = this._decodeRaw(base58string)\n    if (intArray.byteLength < 5) {\n      throw new Error('invalid_input_size: decoded data must have length >= 5')\n    }\n    if (!this._verifyCheckSum(intArray)) {\n      throw new Error('checksum_invalid')\n    }\n    return intArray.slice(0, -4)\n  }\n\n  private _encodeVersioned(\n    bytes: ByteArray,\n    versions: number[],\n    expectedLength: number,\n  ): string {\n    if (!checkByteLength(bytes, expectedLength)) {\n      throw new Error(\n        'unexpected_payload_length: bytes.length does not match expectedLength.' +\n          ' Ensure that the bytes are a Uint8Array.',\n      )\n    }\n    return this.encodeChecked(concatArgs(versions, bytes))\n  }\n\n  private _encodeRaw(bytes: ByteArray): string {\n    return this._codec.encode(Uint8Array.from(bytes))\n  }\n  /* eslint-enable max-lines-per-function */\n\n  private _decodeRaw(base58string: string): Uint8Array {\n    return this._codec.decode(base58string)\n  }\n\n  private _verifyCheckSum(bytes: ByteArray): boolean {\n    const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4)\n    const checksum = bytes.slice(-4)\n    return arrayEqual(computed, checksum)\n  }\n}\n\n/**\n * XRP codec\n */\n\n// base58 encodings: https://xrpl.org/base58-encodings.html\n// Account address (20 bytes)\nconst ACCOUNT_ID = 0\n// Account public key (33 bytes)\nconst ACCOUNT_PUBLIC_KEY = 0x23\n// 33; Seed value (for secret keys) (16 bytes)\nconst FAMILY_SEED = 0x21\n// 28; Validation public key (33 bytes)\nconst NODE_PUBLIC = 0x1c\n\n// [1, 225, 75]\nconst ED25519_SEED = [0x01, 0xe1, 0x4b]\n\nconst codecOptions = {\n  sha256,\n}\n\nconst codecWithXrpAlphabet = new Codec(codecOptions)\n\nexport const codec = codecWithXrpAlphabet\n\n// entropy is a Uint8Array of size 16\n// type is 'ed25519' or 'secp256k1'\nexport function encodeSeed(\n  entropy: ByteArray,\n  type: 'ed25519' | 'secp256k1',\n): string {\n  if (!checkByteLength(entropy, 16)) {\n    throw new Error('entropy must have length 16')\n  }\n  const opts = {\n    expectedLength: 16,\n\n    // for secp256k1, use `FAMILY_SEED`\n    versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],\n  }\n\n  // prefixes entropy with version bytes\n  return codecWithXrpAlphabet.encode(entropy, opts)\n}\n\nexport function decodeSeed(\n  seed: string,\n  opts: {\n    versionTypes: ['ed25519', 'secp256k1']\n    versions: Array<number | number[]>\n    expectedLength: number\n  } = {\n    versionTypes: ['ed25519', 'secp256k1'],\n    versions: [ED25519_SEED, FAMILY_SEED],\n    expectedLength: 16,\n  },\n): {\n  version: number[]\n  bytes: Uint8Array\n  type: 'ed25519' | 'secp256k1' | null\n} {\n  return codecWithXrpAlphabet.decode(seed, opts)\n}\n\nexport function encodeAccountID(bytes: ByteArray): string {\n  const opts = { versions: [ACCOUNT_ID], expectedLength: 20 }\n  return codecWithXrpAlphabet.encode(bytes, opts)\n}\n\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexport const encodeAddress = encodeAccountID\n/* eslint-enable import/no-unused-modules */\n\nexport function decodeAccountID(accountId: string): Uint8Array {\n  const opts = { versions: [ACCOUNT_ID], expectedLength: 20 }\n  return codecWithXrpAlphabet.decode(accountId, opts).bytes\n}\n\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexport const decodeAddress = decodeAccountID\n/* eslint-enable import/no-unused-modules */\n\nexport function decodeNodePublic(base58string: string): Uint8Array {\n  const opts = { versions: [NODE_PUBLIC], expectedLength: 33 }\n  return codecWithXrpAlphabet.decode(base58string, opts).bytes\n}\n\nexport function encodeNodePublic(bytes: ByteArray): string {\n  const opts = { versions: [NODE_PUBLIC], expectedLength: 33 }\n  return codecWithXrpAlphabet.encode(bytes, opts)\n}\n\nexport function encodeAccountPublic(bytes: ByteArray): string {\n  const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 }\n  return codecWithXrpAlphabet.encode(bytes, opts)\n}\n\nexport function decodeAccountPublic(base58string: string): Uint8Array {\n  const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 }\n  return codecWithXrpAlphabet.decode(base58string, opts).bytes\n}\n\nexport function isValidClassicAddress(address: string): boolean {\n  try {\n    decodeAccountID(address)\n  } catch (_error) {\n    return false\n  }\n  return true\n}\n\nfunction checkByteLength(bytes: ByteArray, expectedLength: number): boolean {\n  return 'byteLength' in bytes\n    ? bytes.byteLength === expectedLength\n    : bytes.length === expectedLength\n}\n","import {\n  decodeNodePublic,\n  decodeSeed,\n  encodeAccountID,\n  encodeSeed,\n} from 'ripple-address-codec'\nimport { ripemd160 } from '@xrplf/isomorphic/ripemd160'\nimport { sha256 } from '@xrplf/isomorphic/sha256'\nimport { hexToBytes, randomBytes } from '@xrplf/isomorphic/utils'\n\nimport { accountPublicFromPublicGenerator } from './signing-schemes/secp256k1/utils'\nimport Sha512 from './utils/Sha512'\nimport assert from './utils/assert'\nimport type { Algorithm, HexString, KeyPair, SigningScheme } from './types'\nimport {\n  getAlgorithmFromPrivateKey,\n  getAlgorithmFromPublicKey,\n} from './utils/getAlgorithmFromKey'\n\nimport secp256k1 from './signing-schemes/secp256k1'\nimport ed25519 from './signing-schemes/ed25519'\n\nfunction getSigningScheme(algorithm: Algorithm): SigningScheme {\n  const schemes = { 'ecdsa-secp256k1': secp256k1, ed25519 }\n  return schemes[algorithm]\n}\n\nfunction generateSeed(\n  options: {\n    entropy?: Uint8Array\n    algorithm?: Algorithm\n  } = {},\n): string {\n  assert.ok(\n    !options.entropy || options.entropy.length >= 16,\n    'entropy too short',\n  )\n  const entropy = options.entropy\n    ? options.entropy.slice(0, 16)\n    : randomBytes(16)\n  const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1'\n  return encodeSeed(entropy, type)\n}\n\nfunction deriveKeypair(\n  seed: string,\n  options?: {\n    algorithm?: Algorithm\n    validator?: boolean\n    accountIndex?: number\n  },\n): KeyPair {\n  const decoded = decodeSeed(seed)\n  const proposedAlgorithm = options?.algorithm ?? decoded.type\n  const algorithm =\n    proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1'\n  const scheme = getSigningScheme(algorithm)\n  const keypair = scheme.deriveKeypair(decoded.bytes, options)\n  const messageToVerify = Sha512.half('This test message should verify.')\n  const signature = scheme.sign(messageToVerify, keypair.privateKey)\n  /* istanbul ignore if */\n  if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {\n    throw new Error('derived keypair did not generate verifiable signature')\n  }\n  return keypair\n}\n\nfunction sign(messageHex: HexString, privateKey: HexString): HexString {\n  const algorithm = getAlgorithmFromPrivateKey(privateKey)\n  return getSigningScheme(algorithm).sign(hexToBytes(messageHex), privateKey)\n}\n\nfunction verify(\n  messageHex: HexString,\n  signature: HexString,\n  publicKey: HexString,\n): boolean {\n  const algorithm = getAlgorithmFromPublicKey(publicKey)\n  return getSigningScheme(algorithm).verify(\n    hexToBytes(messageHex),\n    signature,\n    publicKey,\n  )\n}\n\nfunction computePublicKeyHash(publicKeyBytes: Uint8Array): Uint8Array {\n  return ripemd160(sha256(publicKeyBytes))\n}\n\nfunction deriveAddressFromBytes(publicKeyBytes: Uint8Array): string {\n  return encodeAccountID(computePublicKeyHash(publicKeyBytes))\n}\n\nfunction deriveAddress(publicKey: string): string {\n  return deriveAddressFromBytes(hexToBytes(publicKey))\n}\n\nfunction deriveNodeAddress(publicKey: string): string {\n  const generatorBytes = decodeNodePublic(publicKey)\n  const accountPublicBytes = accountPublicFromPublicGenerator(generatorBytes)\n  return deriveAddressFromBytes(accountPublicBytes)\n}\n\nexport {\n  generateSeed,\n  deriveKeypair,\n  sign,\n  verify,\n  deriveAddress,\n  deriveNodeAddress,\n  decodeSeed,\n}\n","import { ed25519 as nobleEd25519 } from '@noble/curves/ed25519'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\nimport type { HexString, SigningScheme } from '../../types'\nimport assert from '../../utils/assert'\nimport Sha512 from '../../utils/Sha512'\n\nconst ED_PREFIX = 'ED'\n\nconst ed25519: SigningScheme = {\n  deriveKeypair(entropy: Uint8Array): {\n    privateKey: string\n    publicKey: string\n  } {\n    const rawPrivateKey = Sha512.half(entropy)\n    const privateKey = ED_PREFIX + bytesToHex(rawPrivateKey)\n    const publicKey =\n      ED_PREFIX + bytesToHex(nobleEd25519.getPublicKey(rawPrivateKey))\n    return { privateKey, publicKey }\n  },\n\n  sign(message: Uint8Array, privateKey: HexString): string {\n    assert.ok(message instanceof Uint8Array, 'message must be array of octets')\n    assert.ok(\n      privateKey.length === 66,\n      'private key must be 33 bytes including prefix',\n    )\n    return bytesToHex(nobleEd25519.sign(message, privateKey.slice(2)))\n  },\n\n  verify(\n    message: Uint8Array,\n    signature: HexString,\n    publicKey: string,\n  ): boolean {\n    // Unlikely to be triggered as these are internal and guarded by getAlgorithmFromKey\n    assert.ok(\n      publicKey.length === 66,\n      'public key must be 33 bytes including prefix',\n    )\n    return nobleEd25519.verify(\n      signature,\n      message,\n      // Remove the 0xED prefix\n      publicKey.slice(2),\n      // By default, set zip215 to false for compatibility reasons.\n      // ZIP 215 is a stricter Ed25519 signature verification scheme.\n      // However, setting it to false adheres to the more commonly used\n      // RFC8032 / NIST186-5 standards, making it compatible with systems\n      // like the XRP Ledger.\n      { zip215: false },\n    )\n  },\n}\n\nexport default ed25519\n","import { numberToBytesBE } from '@noble/curves/abstract/utils'\nimport { secp256k1 as nobleSecp256k1 } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\nimport type {\n  DeriveKeyPairOptions,\n  HexString,\n  SigningScheme,\n} from '../../types'\n\nimport { derivePrivateKey } from './utils'\nimport assert from '../../utils/assert'\nimport Sha512 from '../../utils/Sha512'\n\nconst SECP256K1_PREFIX = '00'\n\nconst secp256k1: SigningScheme = {\n  deriveKeypair(\n    entropy: Uint8Array,\n    options?: DeriveKeyPairOptions,\n  ): {\n    privateKey: string\n    publicKey: string\n  } {\n    const derived = derivePrivateKey(entropy, options)\n    const privateKey =\n      SECP256K1_PREFIX + bytesToHex(numberToBytesBE(derived, 32))\n\n    const publicKey = bytesToHex(nobleSecp256k1.getPublicKey(derived, true))\n    return { privateKey, publicKey }\n  },\n\n  sign(message: Uint8Array, privateKey: HexString): string {\n    // Some callers pass the privateKey with the prefix, others without.\n    // @noble/curves will throw if the key is not exactly 32 bytes, so we\n    // normalize it before passing to the sign method.\n    assert.ok(\n      (privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX)) ||\n        privateKey.length === 64,\n    )\n    const normedPrivateKey =\n      privateKey.length === 66 ? privateKey.slice(2) : privateKey\n    return nobleSecp256k1\n      .sign(Sha512.half(message), normedPrivateKey, {\n        // \"Canonical\" signatures\n        lowS: true,\n        // Would fail tests if signatures aren't deterministic\n        extraEntropy: undefined,\n      })\n      .toDERHex(true)\n      .toUpperCase()\n  },\n\n  verify(\n    message: Uint8Array,\n    signature: HexString,\n    publicKey: HexString,\n  ): boolean {\n    const decoded = nobleSecp256k1.Signature.fromDER(signature)\n    return nobleSecp256k1.verify(decoded, Sha512.half(message), publicKey)\n  },\n}\n\nexport default secp256k1\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport Sha512 from '../../utils/Sha512'\n\nconst ZERO = BigInt(0)\n\nfunction deriveScalar(bytes: Uint8Array, discrim?: number): bigint {\n  const order = secp256k1.CURVE.n\n  for (let i = 0; i <= 0xffff_ffff; i++) {\n    // We hash the bytes to find a 256-bit number, looping until we are sure it\n    // is less than the order of the curve.\n    const hasher = new Sha512().add(bytes)\n    // If the optional discriminator index was passed in, update the hash.\n    if (discrim !== undefined) {\n      hasher.addU32(discrim)\n    }\n    hasher.addU32(i)\n    const key = hasher.first256BigInt()\n    /* istanbul ignore else */\n    if (key > ZERO && key < order) {\n      return key\n    }\n  }\n  // This error is practically impossible to reach.\n  // The order of the curve describes the (finite) amount of points on the curve\n  // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n  // How often will an (essentially) random number generated by Sha512 be larger than that?\n  // There's 2^32 chances (the for loop) to get a number smaller than the order,\n  // and it's rare that you'll even get past the first loop iteration.\n  // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined\n  //\n  /* istanbul ignore next */\n  throw new Error('impossible unicorn ;)')\n}\n\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bigint} 256 bit scalar value.\n *\n */\nexport function derivePrivateKey(\n  seed: Uint8Array,\n  opts: {\n    validator?: boolean\n    accountIndex?: number\n  } = {},\n): bigint {\n  const root = opts.validator\n  const order = secp256k1.CURVE.n\n\n  // This private generator represents the `root` private key, and is what's\n  // used by validators for signing when a keypair is generated from a seed.\n  const privateGen = deriveScalar(seed)\n  if (root) {\n    // As returned by validation_create for a given seed\n    return privateGen\n  }\n  const publicGen =\n    secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true)\n  // A seed can generate many keypairs as a function of the seed and a uint32.\n  // Almost everyone just uses the first account, `0`.\n  const accountIndex = opts.accountIndex || 0\n  return (deriveScalar(publicGen, accountIndex) + privateGen) % order\n}\n\nexport function accountPublicFromPublicGenerator(publicGenBytes: Uint8Array) {\n  const rootPubPoint = secp256k1.ProjectivePoint.fromHex(publicGenBytes)\n  const scalar = deriveScalar(publicGenBytes, 0)\n  const point = secp256k1.ProjectivePoint.BASE.multiply(scalar)\n  const offset = rootPubPoint.add(point)\n  return offset.toRawBytes(true)\n}\n","import { sha512 } from '@xrplf/isomorphic/sha512'\nimport { bytesToNumberBE } from '@noble/curves/abstract/utils'\n\ntype Input = Uint8Array | number[] | string\n\nexport default class Sha512 {\n  // instantiate empty sha512 hash\n  hash = sha512.create()\n\n  static half(input: Input): Uint8Array {\n    return new Sha512().add(input).first256()\n  }\n\n  add(bytes: Input): this {\n    this.hash.update(bytes)\n    return this\n  }\n\n  addU32(i: number): this {\n    const buffer = new Uint8Array(4)\n    new DataView(buffer.buffer).setUint32(0, i)\n    return this.add(buffer)\n  }\n\n  finish(): Uint8Array {\n    return this.hash.digest()\n  }\n\n  first256(): Uint8Array {\n    return this.finish().slice(0, 32)\n  }\n\n  first256BigInt(): bigint {\n    return bytesToNumberBE(this.first256())\n  }\n}\n","const assertHelper: {\n  ok: (cond: boolean, message?: string) => asserts cond is true\n} = {\n  ok(cond, message): asserts cond is true {\n    if (!cond) {\n      throw new Error(message)\n    }\n  },\n}\n\nexport default assertHelper\n","import type { Algorithm, HexString, KeyType } from '../types'\n\nenum Prefix {\n  NONE = -1,\n  ED25519 = 0xed,\n  SECP256K1_PUB_X = 0x02,\n  SECP256K1_PUB_X_ODD_Y = 0x03,\n  SECP256K1_PUB_XY = 0x04,\n  SECP256K1_PRIVATE = 0x00,\n}\n\ntype CompositeKey = `${KeyType}_${Prefix}_${number}`\n\n/**\n * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |\n * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|\n * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |\n * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |\n * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |\n * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |\n * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |\n * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |\n * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |\n *\n * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number\n *       and the interpreted number is the same as 32 bytes.\n */\nconst KEY_TYPES: Record<CompositeKey, Algorithm> = {\n  [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1',\n}\n\nfunction getKeyInfo(key: HexString) {\n  return {\n    prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),\n    len: key.length / 2,\n  }\n}\n\nfunction prefixRepr(prefix: Prefix): string {\n  return prefix === Prefix.NONE\n    ? 'None'\n    : `0x${prefix.toString(16).padStart(2, '0')}`\n}\n\nfunction getValidFormatsTable(type: KeyType) {\n  // No need overkill with renderTable method\n  const padding = 2\n  const colWidth = {\n    algorithm: 'ecdsa-secp256k1'.length + padding,\n    prefix: '0x00'.length + padding,\n  }\n\n  return Object.entries(KEY_TYPES)\n    .filter(([key]) => key.startsWith(type))\n    .map(([key, algorithm]) => {\n      const [, prefix, length] = key.split('_')\n      const paddedAlgo = algorithm.padEnd(colWidth.algorithm)\n      const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix)\n      return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`\n    })\n    .join('\\n')\n}\n\nfunction keyError({\n  key,\n  type,\n  prefix,\n  len,\n}: {\n  key: string\n  type: KeyType\n  prefix: number\n  len: number\n}) {\n  const validFormats = getValidFormatsTable(type)\n\n  return `invalid_key:\n\nType: ${type}\nKey: ${key}\nPrefix: ${prefixRepr(prefix)} \nLength: ${len} bytes\n\nAcceptable ${type} formats are:\n${validFormats}\n`\n}\n\n/**\n * Determines the algorithm associated with a given key (public/private).\n *\n * @param key - hexadecimal string representation of the key.\n * @param type - whether expected key is public or private\n * @returns Algorithm algorithm for signing/verifying\n * @throws Error when key is invalid\n */\nexport function getAlgorithmFromKey(key: HexString, type: KeyType): Algorithm {\n  const { prefix, len } = getKeyInfo(key)\n  // Special case back compat support for no prefix\n  const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix\n  const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`]\n\n  if (!algorithm) {\n    throw new Error(keyError({ key, type, len, prefix: usedPrefix }))\n  }\n  return algorithm\n}\n\nexport function getAlgorithmFromPublicKey(key: HexString): Algorithm {\n  return getAlgorithmFromKey(key, 'public')\n}\n\nexport function getAlgorithmFromPrivateKey(key: HexString): Algorithm {\n  return getAlgorithmFromKey(key, 'private')\n}\n","export * from './schema/Account'\nexport * from './utils'\n","import { deriveAddress, deriveKeypair, generateSeed } from 'ripple-keypairs'\n\nimport {\n  entropyToSecret,\n  parseSecretString,\n  randomSecret,\n  secretToEntropy,\n} from '../utils'\n\n/* Types ==================================================================== */\n\nexport interface Keypair {\n  publicKey: string\n  privateKey: string\n}\n\ninterface AccountData {\n  familySeed: string\n  address: string\n  keypair: Keypair\n}\n\n/* Class ==================================================================== */\n\nexport class Account {\n  private readonly _secret: string[]\n  private readonly _account: AccountData = {\n    familySeed: '',\n    address: '',\n    keypair: {\n      publicKey: '',\n      privateKey: '',\n    },\n  }\n\n  constructor(secretNumbers?: string[] | string | Uint8Array) {\n    if (typeof secretNumbers === 'string') {\n      this._secret = parseSecretString(secretNumbers)\n    } else if (Array.isArray(secretNumbers)) {\n      this._secret = secretNumbers\n    } else if (secretNumbers instanceof Uint8Array) {\n      this._secret = entropyToSecret(secretNumbers)\n    } else {\n      this._secret = randomSecret()\n    }\n\n    validateLengths(this._secret)\n    this.derive()\n  }\n\n  getSecret(): string[] {\n    return this._secret\n  }\n\n  getSecretString(): string {\n    return this._secret.join(' ')\n  }\n\n  getAddress(): string {\n    return this._account.address\n  }\n\n  getFamilySeed(): string {\n    return this._account.familySeed\n  }\n\n  getKeypair(): Keypair {\n    return this._account.keypair\n  }\n\n  toString(): string {\n    return this.getSecretString()\n  }\n\n  private derive(): void {\n    try {\n      const entropy = secretToEntropy(this._secret)\n      this._account.familySeed = generateSeed({ entropy })\n      this._account.keypair = deriveKeypair(this._account.familySeed)\n      this._account.address = deriveAddress(this._account.keypair.publicKey)\n    } catch (error) {\n      let message = 'Unknown Error'\n      if (error instanceof Error) {\n        message = error.message\n      }\n      // we'll proceed, but let's report it\n      throw new Error(message)\n    }\n  }\n}\n\nfunction validateLengths(secretNumbers: string[]): void {\n  if (secretNumbers.length !== 8) {\n    throw new Error('Secret must have 8 numbers')\n  }\n  secretNumbers.forEach((num) => {\n    if (num.length !== 6) {\n      throw new Error('Each secret number must be 6 digits')\n    }\n  })\n}\n","import {\n  bytesToHex,\n  concat,\n  hexToBytes,\n  randomBytes,\n} from '@xrplf/isomorphic/utils'\n\nfunction randomEntropy(): Uint8Array {\n  return randomBytes(16)\n}\n\nfunction calculateChecksum(position: number, value: number): number {\n  return (value * (position * 2 + 1)) % 9\n}\n\nfunction checkChecksum(\n  position: number,\n  value: number | string,\n  checksum?: number,\n): boolean {\n  let normalizedChecksum: number\n  let normalizedValue: number\n\n  if (typeof value === 'string') {\n    if (value.length !== 6) {\n      throw new Error('value must have a length of 6')\n    }\n    normalizedChecksum = parseInt(value.slice(5), 10)\n    normalizedValue = parseInt(value.slice(0, 5), 10)\n  } else {\n    if (typeof checksum !== 'number') {\n      throw new Error('checksum must be a number when value is a number')\n    }\n    normalizedChecksum = checksum\n    normalizedValue = value\n  }\n  return (normalizedValue * (position * 2 + 1)) % 9 === normalizedChecksum\n}\n\nfunction entropyToSecret(entropy: Uint8Array): string[] {\n  const len = new Array(Math.ceil(entropy.length / 2))\n  const chunks = Array.from(len, (_a, chunk) => {\n    const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2)\n    const no = parseInt(bytesToHex(buffChunk), 16)\n    const fill = '0'.repeat(5 - String(no).length)\n    return fill + String(no) + String(calculateChecksum(chunk, no))\n  })\n  if (chunks.length !== 8) {\n    throw new Error('Chucks must have 8 digits')\n  }\n  return chunks\n}\n\nfunction randomSecret(): string[] {\n  return entropyToSecret(randomEntropy())\n}\n\nfunction secretToEntropy(secret: string[]): Uint8Array {\n  return concat(\n    secret.map((chunk, i) => {\n      const no = Number(chunk.slice(0, 5))\n      const checksum = Number(chunk.slice(5))\n      if (chunk.length !== 6) {\n        throw new Error('Invalid secret: number invalid')\n      }\n      if (!checkChecksum(i, no, checksum)) {\n        throw new Error('Invalid secret part: checksum invalid')\n      }\n      const hex = `0000${no.toString(16)}`.slice(-4)\n      return hexToBytes(hex)\n    }),\n  )\n}\n\nfunction parseSecretString(secret: string): string[] {\n  const normalizedSecret = secret.replace(/[^0-9]/gu, '')\n  if (normalizedSecret.length !== 48) {\n    throw new Error(\n      'Invalid secret string (should contain 8 blocks of 6 digits',\n    )\n  }\n  return Array.from(new Array(8), (_a, index) => {\n    return normalizedSecret.slice(index * 6, (index + 1) * 6)\n  })\n}\n\nexport {\n  randomEntropy,\n  randomSecret,\n  entropyToSecret,\n  secretToEntropy,\n  calculateChecksum,\n  checkChecksum,\n  parseSecretString,\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(628);\n"],"names":["getHash","hash","hmac","key","msgs","concatBytes","randomBytes","curveDef","defHash","create","weierstrass","Object","freeze","_0n","BigInt","_1n","c","bits","constTimeNegate","condition","item","neg","negate","opts","W","windows","Math","ceil","windowSize","unsafeLadder","elm","n","p","ZERO","d","add","double","precomputeWindow","points","base","window","push","i","wNAF","precomputes","f","BASE","mask","maxNumber","shiftBy","offset","wbits","Number","offset1","offset2","abs","cond1","cond2","wNAFCached","P","precomputesMap","transform","_WINDOW_SIZE","comp","get","this","set","curve","validateField","Fp","validateObject","h","Gx","Gy","nBitLength","nByteLength","nLength","ORDER","_2n","_8n","VERIFY_DEFAULT","zip215","CURVE","validateBasic","ut","a","adjustScalarBytes","domain","uvRatio","mapToCurve","validateOpts","CURVE_ORDER","prehash","cHash","cofactor","MASK","modP","u","v","isValid","value","sqrt","inv","e","bytes","data","ctx","phflag","length","Error","inBig","inRange","max","in0MaskRange","assertInRange","assertGE0","pointPrecomputes","Map","isPoint","other","Point","constructor","ex","ey","ez","et","x","toAffine","y","fromAffine","normalizeZ","toInv","invertBatch","map","_setWindowSize","delete","assertValidity","is0","X","Y","Z","T","X2","Y2","Z2","Z4","aX2","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","subtract","wnaf","multiply","scalar","multiplyUnsafe","I","isSmallOrder","isTorsionFree","iz","z","ax","ay","zz","clearCofactor","fromHex","hex","len","BYTES","normed","ensureBytes","slice","lastByte","bytesToNumberLE","y2","isXOdd","isLastByteOdd","fromPrivateKey","privKey","getExtendedPublicKey","point","toRawBytes","numberToBytesLE","toHex","bytesToHex","modN","mod","modN_LE","hashed","head","prefix","pointBytes","hashDomainToScalar","context","Uint8Array","msg","verifyOpts","getPublicKey","sign","options","r","R","s","res","verify","sig","publicKey","SB","error","k","ExtendedPoint","utils","randomPrivateKey","precompute","os2ip","bytesToNumberBE","i2osp","Array","from","fill","strxor","b","arr","isBytes","isNum","isSafeInteger","expand_message_xmd","DST","lenInBytes","utf8ToBytes","outputLen","b_in_bytes","blockLen","r_in_bytes","ell","DST_prime","Z_pad","l_i_b_str","b_0","args","expand_message_xof","dkLen","update","digest","hash_to_field","count","m","expand","_DST","dst","validateDST","log2p","toString","L","len_in_bytes","prb","j","elm_offset","tv","subarray","field","COEFF","reverse","xNum","xDen","yNum","yDen","val","reduce","acc","mul","div","def","hashToCurve","u0","u1","encodeToCurve","encodeDST","_3n","_4n","_5n","result","pow","num","power","modulo","invert","number","q","tonelliShanks","legendreC","Q","S","p1div4","root","eql","sqr","Q1div2","ONE","g","t2","ge","FpSqrt","c1","n2","nv","sub","isNegativeLE","FIELD_FIELDS","FpPow","FpInvertBatch","nums","tmp","lastMultiplied","inverted","reduceRight","_nBitLength","undefined","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","BITS","lhs","rhs","legendreConst","bitLen","isLE","redef","sqrtP","bitMask","isOdd","sqrN","addN","subN","mulN","lst","cmov","toBytes","numberToBytesBE","fromBytes","groupOrder","hashLen","minLen","fieldLen","reduced","montgomeryBits","powPminus2","Gu","montgomeryBytes","cswap","swap","x_2","x_3","dummy","assertFieldElement","a24","encodeUCoordinate","scalarMult","pointU","uEnc","decodeUCoordinate","pu","x_1","sw","z_2","z_3","t","k_t","AA","BB","DA","CB","dacb","da_cb","z2","montgomeryLadder","decodeScalar","GuBytes","scalarMultBase","getSharedSecret","privateKey","u8a","hexes","_","padStart","numberToHexUnpadded","hexToNumber","hexToBytes","array","hexByte","byte","parseInt","isNaN","arrays","sum","pad","forEach","title","expectedLength","b1","b2","str","TextEncoder","encode","pos","bitSet","u8n","u8fr","qByteLen","hmacFn","reset","reseed","seed","gen","out","sl","pred","validatorFns","bigint","function","boolean","string","stringOrUint8Array","isArray","object","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","entries","b2n","h2b","DER","Err","super","_parseInt","l","toSig","sBytes","rBytesLeft","hexFromSig","shl","rhl","rl","weierstrassPoints","allowedPrivateKeyLengths","wrapPrivateKey","allowInfinityPoint","endo","beta","splitScalar","validatePointOpts","_c","_isCompressed","tail","weierstrassEquation","x2","x3","isWithinCurveOrder","assertGE","normPrivateKeyToScalar","lengths","includes","assertPrjPoint","px","py","pz","left","right","hasEvenY","U1","U2","b3","t0","t1","t3","t4","t5","k1neg","k1","k2neg","k2","k1p","k2p","fake","f1p","f2p","multiplyAndAddUnsafe","isCompressed","_bits","ProjectivePoint","SWUFpSqrtRatio","o","_2n_pow_c1_1","_2n_pow_c1","c2","c3","c4","c5","c6","c7","sqrtRatio","tv1","tv2","tv3","tv5","tv4","isQR","tvv5","e1","y1","bits2int","bits2int_modN","lowS","compressedLen","uncompressedLen","invN","cat","numToNByteStr","isBiggerThanHalfOrder","slcNum","to","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","ir","u2","hasHighS","normalizeS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","isValidPrivateKey","mapHashToField","isProbPub","delta","ORDER_MASK","int2octets","defaultSigOpts","defaultVerOpts","privateA","publicB","k2sig","some","extraEntropy","ent","h1int","seedArgs","kBytes","ik","normS","prepSig","createHmacDrbg","drbg","signature","sg","_sig","derError","message","is","tv6","ED25519_P","ED25519_SQRT_M1","_10n","_20n","_40n","_80n","ed25519_pow_2_252_3","b4","pow2","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","vx2","root1","root2","useRoot1","useRoot2","noRoot","ED25519_TORSION_SUBGROUP","Field","ed25519Defaults","sha512","ed25519_domain","edwardsToMontgomeryPub","edwardsPub","ed25519","twistedEdwards","ed25519ctx","ed25519ph","x25519","montgomery","edwardsToMontgomery","edwardsPriv","ELL2_C1","ELL2_C2","ELL2_C3","ELL2_C4","ELL2_J","ELL2_C1_EDWARDS","FpSqrtEven","htf","createHasher","scalars","xMn","xMd","yMn","yMd","xd","x1n","gxd","gx1","y11","y12","x2n","y21","y22","gx2","e2","e3","xn","e4","map_to_curve_elligator2_curve25519","yn","yd","map_to_curve_elligator2_edwards25519","assertRstPoint","RistPoint","SQRT_M1","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","invertSqrt","MAX_255B","bytes255ToNumberLE","calcElligatorRistrettoMap","r0","Ns","Ns_D_is_sq","s_","Nt","s2","W0","W1","W2","W3","ep","ap","R1","R2","emsg","equalBytes","u1_2","u2_2","Dx","Dy","u2sq","invsqrt","D1","D2","zInv","_x","_y","one","two","RistrettoPoint","hashToRistretto255","uniform_bytes","hash_to_ristretto255","secp256k1P","secp256k1N","divNearest","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b6","b9","b11","b22","b44","b88","b176","b220","b223","secp256k1","createCurve","a1","a2","POW_2_128","sha256","fe","TAGGED_HASH_PREFIXES","taggedHash","tag","messages","tagP","tagH","charCodeAt","pointToBytes","numTo32b","GmulAdd","schnorrGetExtPubKey","priv","d_","lift_x","xx","challenge","schnorrVerify","pub","schnorr","auxRand","rand","k_","rx","isoMap","isogenyMap","mapSWU","mapToCurveSimpleSWU","bool","exists","instance","checkFinished","destroyed","finished","output","min","assert","SHA2","Hash","padOffset","buffer","view","createView","take","process","dataView","roundClean","digestInto","byteOffset","setBigUint64","_32n","_u32_max","wh","wl","setUint32","oview","outLen","state","destroy","_cloneInto","U32_MASK64","fromBig","le","split","Ah","Uint32Array","Al","toBig","shrSH","_l","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","rotr32H","_h","rotr32L","rotlSH","rotlSL","rotlBH","rotlBL","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","u64","crypto","globalThis","HMAC","_key","iHash","oHash","buf","getPrototypeOf","Rho","Id","idxL","idxR","shifts","shiftsL","idx","shiftsR","Kl","Kr","rotl","word","shift","group","BUF","RIPEMD160","h0","h1","h2","h3","h4","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rr","sr","tl","tr","ripemd160","wrapConstructor","Maj","SHA256_K","IV","SHA256_W","SHA256","W15","s0","rotr","s1","SHA224","sha224","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","CHIl","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","SHA512_224","SHA512_256","SHA384","sha512_224","sha512_256","sha384","u8","byteLength","u32","floor","DataView","nextTick","async","iters","tick","cb","ts","Date","now","diff","clone","toStr","defaults","call","assign","hashCons","hashC","bytesLength","getRandomValues","assertNumber","chain","wrap","decode","alphabet","digits","input","letter","index","indexOf","join","separator","padding","chr","end","normalize","fn","convertRadix","carry","done","digit","digitBase","rounded","defineProperty","exports","stringToBytes","bytesToString","utf8","bech32m","bech32","base58check","base58xmr","base58xrp","base58flickr","base58","base64urlnopad","base64url","base64","base32crockford","base32hex","base32","base16","gcd","radix2carry","convertRadix2","radix","radix2","revPadding","unsafeWrapper","apply","checksum","payload","newChecksum","oldChecksum","toUpperCase","replace","genBase58","abc","XMR_BLOCK_LEN","block","concat","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","words","encodingConst","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","TypeError","lowered","toLowerCase","sepIndex","lastIndexOf","endsWith","actualLength","decodeToBytes","decodeUnsafe","TextDecoder","CODERS","coderTypeError","hasOwnProperty","chash","wrapped","hexToString","stringToHex","views","buf1","buf2","dv1","Int8Array","dv2","codec","encodeSeed","decodeSeed","encodeAccountID","decodeAccountID","encodeNodePublic","decodeNodePublic","encodeAccountPublic","decodeAccountPublic","isValidClassicAddress","PREFIX_BYTES","main","test","encodeXAddress","accountId","theTag","flag","encodeChecked","decodeXAddress","xAddress","decoded","decodeChecked","decodedPrefix","equal","isUint8ArrayForTestAddress","tagFromUint8Array","classicAddressToXAddress","classicAddress","xAddressToClassicAddress","isValidXAddress","_error","arr1","arr2","every","flatMap","arg","ED25519_SEED","codecOptions","codecWithXrpAlphabet","_sha256","_codec","versions","_encodeVersioned","base58string","types","versionTypes","withoutSum","versionLengthGuess","payloadLength","versionBytes","version","arrayEqual","check","_encodeRaw","concatArgs","intArray","_decodeRaw","_verifyCheckSum","checkByteLength","computed","entropy","encodeAddress","decodeAddress","address","getSigningScheme","algorithm","deriveAddressFromBytes","publicKeyBytes","computePublicKeyHash","generateSeed","ok","deriveKeypair","scheme","keypair","messageToVerify","half","messageHex","getAlgorithmFromPrivateKey","getAlgorithmFromPublicKey","deriveAddress","deriveNodeAddress","generatorBytes","accountPublicFromPublicGenerator","rawPrivateKey","derived","derivePrivateKey","startsWith","normedPrivateKey","deriveScalar","discrim","order","hasher","addU32","first256BigInt","validator","privateGen","accountIndex","publicGenBytes","rootPubPoint","Sha512","first256","finish","assertHelper","cond","Prefix","KEY_TYPES","NONE","SECP256K1_PRIVATE","ED25519","SECP256K1_PUB_X","SECP256K1_PUB_X_ODD_Y","SECP256K1_PUB_XY","prefixRepr","getAlgorithmFromKey","getKeyInfo","usedPrefix","validFormats","colWidth","filter","padEnd","getValidFormatsTable","keyError","secretNumbers","_account","familySeed","_secret","parseSecretString","entropyToSecret","randomSecret","validateLengths","derive","getSecret","getSecretString","getAddress","getFamilySeed","getKeypair","secretToEntropy","randomEntropy","calculateChecksum","position","checkChecksum","normalizedChecksum","normalizedValue","chunks","_a","chunk","buffChunk","no","repeat","secret","normalizedSecret","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__"],"sourceRoot":""}